"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCursor = void 0;
const cursor_error_js_1 = require("../../documents/cursors/cursor-error.js");
class AbstractCursor {
        constructor(options, mapping) {
                Object.defineProperty(this, "_consumed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
                Object.defineProperty(this, "_state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'idle'
        });
                Object.defineProperty(this, "_currentPage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "_isNextPage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
                Object.defineProperty(this, "_mapping", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "_timeoutOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._timeoutOptions = options;
        this._mapping = mapping;
    }
        get state() {
        return this._state;
    }
        buffered() {
        return this._currentPage?.result.length ?? 0;
    }
        consumed() {
        return this._consumed;
    }
        consumeBuffer(max) {
        const buffer = this._currentPage?.result ?? [];
        const ret = buffer.splice(0, max ?? buffer.length);
        this._consumed += ret.length;
        return ret;
    }
        close() {
        this._state = 'closed';
        this._currentPage = undefined;
        this._isNextPage = true;
    }
        rewind() {
        this._currentPage = undefined;
        this._isNextPage = true;
        this._state = 'idle';
        this._consumed = 0;
    }
        [Symbol.asyncIterator]() {
        return this._iterator('[asyncIterator]');
    }
        async next() {
        return this._next(false, '.next');
    }
        async hasNext() {
        return await this._next(true, '.hasNext') !== null;
    }
        async forEach(consumer) {
        for await (const doc of this._iterator('.forEach')) {
            const resp = consumer(doc);
            const stop = (resp === undefined) ? resp : await resp;
            if (stop === false) {
                break;
            }
        }
    }
        async toArray() {
        const docs = [];
        const tm = this._tm().multipart('generalMethodTimeoutMs', this._timeoutOptions);
        for await (const doc of this._iterator('.toArray', tm)) {
            docs.push(doc);
        }
        return docs;
    }
        async *_iterator(method, tm) {
        if (this._state === 'closed') {
            throw new cursor_error_js_1.CursorError('Cannot iterate over a closed cursor', this);
        }
        try {
            for (let doc; (doc = await this._next(false, method, tm));) {
                yield doc;
            }
        }
        finally {
            this.close();
        }
    }
        async _next(peek, method, tm) {
        if (this._state === 'closed') {
            return null;
        }
        try {
            this._state = 'started';
            while (!this._currentPage?.result.length) {
                if (!this._isNextPage) {
                    this.close();
                    return null;
                }
                [this._currentPage, this._isNextPage] = await this._fetchNextPage({ method }, tm);
            }
            if (peek) {
                return true;
            }
            const doc = this._currentPage.result.shift();
            if (doc) {
                this._consumed++;
            }
            return (doc && this._mapping)
                ? this._mapping(doc)
                : doc;
        }
        catch (e) {
            this.close();
            throw e;
        }
    }
}
exports.AbstractCursor = AbstractCursor;
